
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <link href="https://fonts.googleapis.com/css2?family=Bungee+Spice&display=swap" rel="stylesheet">
    <title>Bouncing Block</title>
    <style>
        html,
        body { display: flex; height: 100vh; justify-content: center; align-items: center; background-color: #111; color: white; font-family: sans-serif; margin: 0; overflow: hidden; flex-direction: column; }
        canvas { display: none; background: #222; }
        #menu { display: flex; flex-direction: row; align-items: center; gap: 16px; }
        .menuButton { font-size: 2rem; margin-top: 10px; padding: 0.5rem 1rem; background: #212121; color: white; border: none; border-radius: 8px; cursor: pointer; }
        .title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 100px; color: white; background: rgba(0, 0, 0, 0); padding: 10px; border-radius: 5px; font-family: "Bungee Spice", sans-serif; display: block; max-width: 90%; text-align: center; white-space: nowrap; }
        .info { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); font-size: 20px; color: white; background: rgba(0, 0, 0 ,0); padding: 5px; border-radius: 5px; font-family: sans-serif; display: block; max-width: 90%; text-align: center; }
        #menu button:hover { color: white; transform: scale(1.05); transition: transform 0.3s; }
    </style>
</head>
<body>
    <div class="title">BOUNCING BLOCK<br></div>
    <div class="info">v1.0.0<br>Joshua Harding & Ben Messer<br>Goal: Jump as high as you can!<br>Press a button to start</div>
    <div id="menu">
        <button id="startClassic" class="menuButton" onclick="startGame('classic')">Classic</button>
        <button id="startUnderwater" class="menuButton" onclick="startGame('underwater')">Underwater</button>
        <button id="startCave" class="menuButton" onclick="startGame('cave')">Cave</button>
        <button id="startCliff" class="menuButton" onclick="startGame('cliff')">Cliff</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script>
        function startGame(mode) {
            if (mode === "cliff") {
                startCliff();
                return;
            }
            document.querySelector(".title").style.display = "none";
            document.querySelector(".info").style.display = "none";
            document.getElementById('menu').style.display = 'none';
            const canvas = document.getElementById("gameCanvas");
            canvas.style.display = 'block';
            const ctx = canvas.getContext("2d");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const player = {
                x: canvas.width / 2 - 15,
                y: canvas.height - 60,
                width: 30,
                height: 30,
                vx: 0,
                vy: 0,
                speed: 5,
                jump: -15,
                gravity: 0.6,
            };
            const keys = {};
            const platforms = [];
            const crystals = [];
            const dustParticles = [];
            let scrollOffset = 0;
            let maxY = 0;
            let gameOver = false;
            const maxJumpHeight = (player.jump ** 2) / (2 * player.gravity);
            const airTime = Math.sqrt(2 * maxJumpHeight / player.gravity) * 2;
            const maxHorizontalReach = player.speed * airTime;
            const verticalGapMin = 40;
            const verticalGapMax = maxJumpHeight - 10;
            const platformWidthMin = 60;
            const platformWidthMax = 100;
            if (mode === "cave") {
                for (let i = 0; i < 100; i++) {
                dustParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    alpha: Math.random() * 0.1,
                    speed: 0.2 + Math.random() * 0.3,
                });
                }
                platforms.push({
                x: canvas.width / 2 - 100,
                y: canvas.height - 20,
                width: 200,
                height: 20
                });
            } else {
                platforms.push({
                    x: 0,
                    y: canvas.height - 20,
                    width: canvas.width,
                    height: 20
                });
            }
            let lastPlat = platforms[0];
            for (let i = 0; i < 20; i++) {
                lastPlat = createSafePlatform(lastPlat);
                if (mode === "cave") spawnCrystalsAbove(lastPlat.y);
            }
            function randBetween(min, max) {
                return Math.random() * (max - min) + min;
            }
            function createSafePlatform(below) {
                const gapY = randBetween(verticalGapMin, verticalGapMax);
                const newY = below.y - gapY;
                const width = randBetween(platformWidthMin, platformWidthMax);
                let minX = below.x - maxHorizontalReach;
                let maxX = below.x + below.width + maxHorizontalReach - width;
                minX = Math.max(0, minX);
                maxX = Math.min(canvas.width - width, maxX);
                const newX = randBetween(minX, maxX);
                const newPlat = { x: newX, y: newY, width, height: 10 };
                platforms.push(newPlat);
                return newPlat;
            }
            function spawnCrystalsAbove(topY) {
                for (let i = 0; i < 3; i++) {
                    crystals.push({
                        x: Math.random() * canvas.width,
                        y: topY - randBetween(100, 500),
                        radius: 4 + Math.random() * 4,
                        glow: 0.3 + Math.random() * 0.7
                    });
                }
            }
            window.addEventListener('keydown', e => keys[/^[a-z]$/i.test(e.key) ? e.key.toLowerCase() : e.key] = true);
            window.addEventListener('keyup', e => keys[/^[a-z]$/i.test(e.key) ? e.key.toLowerCase() : e.key] = false);
            document.addEventListener("keydown", e => {
                document.body.style.cursor = "none";
                if (gameOver && e.key === "r") {
                    restartGame();
                }
            });
            document.addEventListener("mousemove", e => document.body.style.cursor = "default");
            function restartGame() {
                gameOver = false;
                player.x = canvas.width / 2 - player.width / 2;
                player.y = canvas.height - 60;
                player.vx = 0;
                player.vy = 0;
                scrollOffset = 0;
                maxY = 0;
                platforms.length = 0;
                crystals.length = 0;
                dustParticles.length = 0;
                if (mode === "cave") {
                    for (let i = 0; i < 100; i++) {
                        dustParticles.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            alpha: Math.random() * 0.1,
                            speed: 0.2 + Math.random() * 0.3,
                        });
                    }
                    platforms.push({
                        x: canvas.width / 2 - 100,
                        y: canvas.height - 20,
                        width: 200,
                        height: 20
                    });
                } else {
                    platforms.push({
                        x: 0,
                        y: canvas.height - 20,
                        width: canvas.width,
                        height: 20
                    });
                }
                lastPlat = platforms[0];
                for (let i = 0; i < 20; i++) {
                    lastPlat = createSafePlatform(lastPlat);
                    if (mode === "cave") spawnCrystalsAbove(lastPlat.y);
                }
            }
            function update() {
                if (gameOver) return;
                if (keys["ArrowLeft"] || keys["a"]) player.vx = -player.speed;
                else if (keys["ArrowRight"] || keys["d"]) player.vx = player.speed;
                else player.vx = 0;
                player.vy += player.gravity;
                player.x += player.vx;
                player.y += player.vy;
                if (player.x < -player.width) player.x = canvas.width;
                if (player.x > canvas.width) player.x = -player.width;
                for (const plat of platforms) {
                    if (
                        player.vy > 0 &&
                        player.x < plat.x + plat.width &&
                        player.x + player.width > plat.x &&
                        player.y + player.height > plat.y &&
                        player.y + player.height < plat.y + plat.height + player.vy
                    ) {
                        player.vy = player.jump;
                    }
                }
                if (player.y < canvas.height / 2) {
                    const delta = canvas.height / 2 - player.y;
                    player.y = canvas.height / 2;
                    scrollOffset += delta;
                    maxY += delta;
                    for (const plat of platforms) plat.y += delta;
                    if (mode === "cave") {
                        for (const crystal of crystals) crystal.y += delta;
                        for (const dust of dustParticles) dust.y += delta;
                    }
                }
                for (let i = platforms.length - 1; i >= 0; i--) {
                    if (platforms[i].y > canvas.height + 100) {
                        platforms.splice(i, 1);
                    }
                }
                if (mode === "cave") {
                    for (let i = crystals.length - 1; i >= 0; i--) {
                        if (crystals[i].y > canvas.height + 100) crystals.splice(i, 1);
                    }
                    for (let i = dustParticles.length - 1; i >= 0; i--) {
                        if (dustParticles[i].y > canvas.height + 100) dustParticles.splice(i, 1);
                    }
                    if (dustParticles.length < 200) {
                        dustParticles.push({
                            x: Math.random() * canvas.width,
                            y: (Math.random() * canvas.height) - 1,
                            alpha: Math.random() * 0.1,
                            speed: 0.2 + Math.random() * 0.3,
                        });
                    }
                }
                let topMost = platforms.reduce((min, p) => p.y < min.y ? p : min, platforms[0]);
                while (topMost.y > -verticalGapMax) {
                    topMost = createSafePlatform(topMost);
                    if (mode === "cave") spawnCrystalsAbove(topMost.y);
                }
                if (mode === "cave") {
                    for (const dust of dustParticles) {
                        dust.y += dust.speed;
                        if (dust.y < -5) dust.y = canvas.height + 5;
                    }
                }
                if (player.y > canvas.height + 50) gameOver = true;
            }
            if (mode === "classic") {
                function draw() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    function drawRoundedRect(ctx, x, y, width, height, radius = 8) {
                        ctx.beginPath();
                        ctx.moveTo(x + radius, y);
                        ctx.lineTo(x + width - radius, y);
                        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                        ctx.lineTo(x + width, y + height - radius);
                        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                        ctx.lineTo(x + radius, y + height);
                        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                        ctx.lineTo(x, y + radius);
                        ctx.quadraticCurveTo(x, y, x + radius, y);
                        ctx.closePath();
                        ctx.fill();
                    }
                    for (const plat of platforms) {
                        ctx.save();
                        ctx.shadowColor = "rgba(0,0,0,0.5)";
                        ctx.shadowBlur = 12;
                        ctx.shadowOffsetY = 4;
                        ctx.fillStyle = "#4CAF50";
                        drawRoundedRect(ctx, plat.x, plat.y, plat.width, plat.height, 6);
                        ctx.restore();
                    }
                    ctx.save();
                    const grad = ctx.createLinearGradient(player.x, player.y, player.x, player.y + player.height);
                    grad.addColorStop(0, "#FFEE58");
                    grad.addColorStop(1, "#FDD835");
                    ctx.fillStyle = grad;
                    ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetY = 4;
                    drawRoundedRect(ctx, player.x, player.y, player.width, player.height, 8);
                    ctx.restore();
                    ctx.save();
                    ctx.font = "20px 'Courier New', monospace";
                    ctx.fillStyle = "#fff";
                    ctx.shadowColor = "#000";
                    ctx.shadowBlur = 6;
                    ctx.fillText("Height: " + Math.floor(maxY), 12, 30);
                    ctx.restore();
                    if (gameOver) {
                        ctx.save();
                        ctx.font = "48px sans-serif";
                        ctx.fillStyle = "#fff";
                        ctx.shadowColor = "#000";
                        ctx.shadowBlur = 8;
                        ctx.textAlign = "center";
                        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
                        ctx.font = "20px sans-serif";
                        ctx.fillText("Press R to Restart", canvas.width / 2, canvas.height / 2 + 40);
                        ctx.restore();
                    }
                }
            } else if (mode === "underwater") {
                function drawRoundedRect(ctx, x, y, width, height, radius = 8) {
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                    ctx.fill();
                }

                function drawUnderwaterPlatform(x, y, width, height) {
                    ctx.beginPath();
                    const roughness = 4;
                    const steps = Math.floor(width / roughness);
                    let prevX = x, prevY = y;

                    ctx.moveTo(prevX, prevY);
                    for (let i = 1; i <= steps; i++) {
                        const nextX = x + (i * roughness);
                        const nextY = y + Math.sin(i * 0.8) * 2;
                        ctx.lineTo(nextX, nextY);
                    }
                    ctx.lineTo(x + width, y + height);
                    ctx.lineTo(x, y + height);
                    ctx.closePath();
                    const rockGradient = ctx.createLinearGradient(x, y, x, y + height);
                    rockGradient.addColorStop(0, "#5D4037");
                    rockGradient.addColorStop(1, "#3E2723");
                    ctx.fillStyle = rockGradient;
                    ctx.fill();
                }
                function drawUnderwaterMountains() {
                    ctx.save();
                    ctx.fillStyle = "#2E3A59";
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height);
                    for (let x = 0; x <= canvas.width; x += 80) {
                        const y = canvas.height - 100 - Math.sin(x * 0.01) * 60;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
                function draw() {
                    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    sky.addColorStop(0, "#4A90E2");
                    sky.addColorStop(1, "#003366");
                    ctx.fillStyle = sky;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    drawUnderwaterMountains();
                    for (const plat of platforms) {
                        ctx.save();
                        ctx.shadowColor = "rgba(0,0,0,0.3)";
                        ctx.shadowBlur = 10;
                        drawUnderwaterPlatform(plat.x, plat.y, plat.width, plat.height);
                        ctx.restore();
                    }
                    ctx.save();
                    ctx.shadowColor = "rgba(0,0,0,0.4)";
                    ctx.shadowBlur = 12;
                    const grad = ctx.createLinearGradient(player.x, player.y, player.x, player.y + player.height);
                    grad.addColorStop(0, "#FFEA00");
                    grad.addColorStop(1, "#FFC107");
                    ctx.fillStyle = grad;
                    drawRoundedRect(ctx, player.x, player.y, player.width, player.height, 6);
                    ctx.restore();
                    ctx.save();
                    ctx.font = "20px 'Courier New', monospace";
                    ctx.fillStyle = "#fff";
                    ctx.shadowColor = "black";
                    ctx.shadowBlur = 4;
                    ctx.fillText("Height: " + Math.floor(maxY), 12, 30);
                    ctx.restore();
                    if (gameOver) {
                        ctx.save();
                        ctx.font = "48px sans-serif";
                        ctx.fillStyle = "#fff";
                        ctx.shadowColor = "#000";
                        ctx.shadowBlur = 8;
                        ctx.textAlign = "center";
                        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
                        ctx.font = "20px sans-serif";
                        ctx.fillText("Press R to Restart", canvas.width / 2, canvas.height / 2 + 40);
                        ctx.restore();
                    }
                }
            } else if (mode === "cave") {
                function drawCaveBackground() {
                    const caveGrad = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 100,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    caveGrad.addColorStop(0, "#1a1a1a");
                    caveGrad.addColorStop(1, "#0a0a0a");
                    ctx.fillStyle = caveGrad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    for (const dust of dustParticles) {
                        ctx.fillStyle = `rgba(255,255,255,${dust.alpha})`;
                        ctx.fillRect(dust.x, dust.y, 5, 5);
                    }
                    for (const crystal of crystals) {
                        ctx.beginPath();
                        ctx.arc(crystal.x, crystal.y, crystal.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(173, 216, 230, ${crystal.glow})`;
                        ctx.shadowColor = `rgba(173, 216, 230, ${crystal.glow})`;
                        ctx.shadowBlur = 20 * crystal.glow;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
                function drawLedge(plat) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(plat.x, plat.y);
                    ctx.lineTo(plat.x + plat.width, plat.y);
                    ctx.lineTo(plat.x + plat.width - 10, plat.y + plat.height);
                    ctx.lineTo(plat.x + 10, plat.y + plat.height);
                    ctx.closePath();
                    const ledgeGrad = ctx.createLinearGradient(plat.x, plat.y, plat.x, plat.y + plat.height);
                    ledgeGrad.addColorStop(0, "#4e342e");
                    ledgeGrad.addColorStop(1, "#2e1d14");
                    ctx.fillStyle = ledgeGrad;
                    ctx.shadowColor = "rgba(0,0,0,0.6)";
                    ctx.shadowBlur = 4;
                    ctx.fill();
                    ctx.restore();
                }
                function drawRoundedRect(ctx, x, y, width, height, radius = 8) {
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                    ctx.fill();
                }
                function draw() {
                    drawCaveBackground();
                    for (const plat of platforms) drawLedge(plat);
                    ctx.save();
                    ctx.shadowColor = "#FFD700";
                    ctx.shadowBlur = 20;
                    const grad = ctx.createLinearGradient(player.x, player.y, player.x, player.y + player.height);
                    grad.addColorStop(0, "#FFEA00");
                    grad.addColorStop(1, "#FFC107");
                    ctx.fillStyle = grad;
                    drawRoundedRect(ctx, player.x, player.y, player.width, player.height, 6);
                    ctx.restore();
                    ctx.save();
                    ctx.font = "20px 'Courier New', monospace";
                    ctx.fillStyle = "#fff";
                    ctx.shadowColor = "black";
                    ctx.shadowBlur = 4;
                    ctx.fillText("Height: " + Math.floor(maxY), 12, 30);
                    ctx.restore();
                    if (gameOver) {
                        ctx.save();
                        ctx.font = "40px sans-serif";
                        ctx.fillStyle = "white";
                        ctx.textAlign = "center";
                        ctx.shadowColor = "black";
                        ctx.shadowBlur = 6;
                        ctx.fillText("You Fell Into The Abyss!", canvas.width / 2, canvas.height / 2);
                        ctx.font = "20px sans-serif";
                        ctx.fillText("Press R to Restart", canvas.width / 2, canvas.height / 2 + 40);
                        ctx.restore();
                    }
                }
            }
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }
        function startCliff() {
            document.querySelector(".title").style.display = "none";
            document.querySelector(".info").style.display = "none";
            document.getElementById('menu').style.display = 'none';
            document.getElementById("gameCanvas").style.display = 'block';
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const cliffWidth = canvas.width * 0.35;
            const cliffX = (canvas.width - cliffWidth) / 2;
            const player = {
                x: canvas.width / 2 - 15,
                y: canvas.height - 80,
                width: 30,
                height: 30,
                vx: 0,
                vy: 0,
                speed: 5,
                jump: -15,
                gravity: 0.6,
            };
            const keys = {};
            const platforms = [];
            let scrollOffset = 0;
            let maxY = 0;
            let gameOver = false;
            const maxJumpHeight = (player.jump ** 2) / (2 * player.gravity);
            const airTime = Math.sqrt(2 * maxJumpHeight / player.gravity) * 2;
            const maxHorizontalReach = player.speed * airTime;
            const verticalGapMin = 40;
            const verticalGapMax = maxJumpHeight - 10;
            platforms.push({
                x: canvas.width / 2 - 90,
                y: canvas.height - 20,
                width: 180,
                height: 14
            });
            let lastPlat = platforms[0];
            for (let i = 0; i < 20; i++) {
                lastPlat = createSafePlatform(lastPlat);
            }
            // ðŸª¨ Generate cliff segments upward
            const cliffSegments = [];
            function generateCliffSegments(startY) {
                let y = startY;
                while (y > -2000) {
                    const bulgeLeft = randBetween(-20, 20);
                    const bulgeRight = randBetween(-20, 20);
                    cliffSegments.push({
                        y,
                        left: bulgeLeft,
                        right: bulgeRight
                    });
                    y -= randBetween(30, 70);
                }
            }
            generateCliffSegments(canvas.height);
            function randBetween(min, max) {
                return Math.random() * (max - min) + min;
            }
            function createSafePlatform(below) {
                const gapY = randBetween(verticalGapMin, verticalGapMax);
                const newY = below.y - gapY;
                const width = randBetween(60, 100);
                const leftBound = Math.max(cliffX + 10, below.x - maxHorizontalReach);
                const rightBound = Math.min(cliffX + cliffWidth - width - 10, below.x + maxHorizontalReach);
                const newX = randBetween(leftBound, rightBound);
                const newPlat = { x: newX, y: newY, width, height: 12 };
                platforms.push(newPlat);
                return newPlat;
            }
            window.addEventListener('keydown', e => keys[/^[a-z]$/i.test(e.key) ? e.key.toLowerCase() : e.key] = true);
            window.addEventListener('keyup', e => keys[/^[a-z]$/i.test(e.key) ? e.key.toLowerCase() : e.key] = false);
            document.addEventListener("keydown", e => {
                document.body.style.cursor = "none";
                if (e.key === "r" && gameOver) {
                    gameOver = false;
                    player.x = canvas.width / 2 - 15;
                    player.y = canvas.height - 80;
                    player.vx = 0;
                    player.vy = 0;
                    platforms.length = 0;
                    cliffSegments.length = 0;
                    scrollOffset = 0;
                    maxY = 0;
                    platforms.push({
                        x: canvas.width / 2 - 90,
                        y: canvas.height - 20,
                        width: 180,
                        height: 14
                    });
                    lastPlat = platforms[0];
                    for (let i = 0; i < 20; i++) {
                        lastPlat = createSafePlatform(lastPlat);
                    }
                    generateCliffSegments(canvas.height);
                }
            });
            document.addEventListener("mousemove", e => document.body.style.cursor = "default");
            function update() {
                if (gameOver) return;
                if (keys["ArrowLeft"] || keys["a"]) player.vx = -player.speed;
                else if (keys["ArrowRight"] || keys["d"]) player.vx = player.speed;
                else player.vx = 0;
                player.vy += player.gravity;
                player.x += player.vx;
                player.y += player.vy;
                if (player.x < -player.width) player.x = canvas.width;
                if (player.x > canvas.width) player.x = -player.width;
                for (const plat of platforms) {
                    if (
                        player.vy > 0 &&
                        player.x + 4 < plat.x + plat.width &&
                        player.x + player.width - 4 > plat.x &&
                        player.y + player.height > plat.y &&
                        player.y + player.height < plat.y + plat.height + player.vy
                    ) {
                        player.vy = player.jump;
                    }
                }
                if (player.y < canvas.height / 2) {
                    const delta = canvas.height / 2 - player.y;
                    player.y = canvas.height / 2;
                    scrollOffset += delta;
                    maxY += delta;
                    for (const plat of platforms) plat.y += delta;
                    for (const seg of cliffSegments) seg.y += delta;
                }
                for (let i = platforms.length - 1; i >= 0; i--) {
                    if (platforms[i].y > canvas.height + 100) platforms.splice(i, 1);
                }
                let topMost = platforms.reduce((min, p) => p.y < min.y ? p : min, platforms[0]);
                while (topMost.y > -verticalGapMax) topMost = createSafePlatform(topMost);
                let topCliff = cliffSegments.reduce((min, s) => s.y < min.y ? s : min, cliffSegments[0]);
                if (topCliff.y > -1000) generateCliffSegments(topCliff.y);
                if (player.y > canvas.height + 50) gameOver = true;
            }
            function drawCliff() {
                ctx.beginPath();
                let started = false;
                for (let i = 0; i < cliffSegments.length; i++) {
                    const seg = cliffSegments[i];
                    const leftX = cliffX + seg.left;
                    const rightX = cliffX + cliffWidth + seg.right;
                    if (!started) {
                        ctx.moveTo(leftX, seg.y);
                        started = true;
                    } else {
                        ctx.lineTo(leftX, seg.y);
                    }
                }
                for (let i = cliffSegments.length - 1; i >= 0; i--) {
                    const seg = cliffSegments[i];
                    const rightX = cliffX + cliffWidth + seg.right;
                    ctx.lineTo(rightX, seg.y);
                }
                ctx.closePath();
                const grad = ctx.createLinearGradient(cliffX, 0, cliffX + cliffWidth, 0);
                grad.addColorStop(0, "#6d6d6d");
                grad.addColorStop(1, "#4d4d4d");
                ctx.fillStyle = grad;
                ctx.fill();
            }
            function drawPlatform(plat) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(plat.x, plat.y);
                ctx.lineTo(plat.x + plat.width, plat.y);
                ctx.lineTo(plat.x + plat.width - 10, plat.y + plat.height);
                ctx.lineTo(plat.x + 10, plat.y + plat.height);
                ctx.closePath();
                const ledgeGrad = ctx.createLinearGradient(plat.x, plat.y, plat.x, plat.y + plat.height);
                ledgeGrad.addColorStop(0, "#6d4c41");
                ledgeGrad.addColorStop(1, "#4e342e");
                ctx.fillStyle = ledgeGrad;
                ctx.shadowColor = "rgba(0,0,0,0.4)";
                ctx.shadowBlur = 6;
                ctx.fill();
                ctx.restore();
            }
            function drawRoundedRect(ctx, x, y, width, height, radius = 8) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
            }
            function drawSky() {
                const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
                sky.addColorStop(0, "#87CEEB");
                sky.addColorStop(1, "#B0E0E6");
                ctx.fillStyle = sky;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            function draw() {
                drawSky();
                drawCliff();
                for (const plat of platforms) drawPlatform(plat);
                ctx.save();
                ctx.shadowColor = "rgba(0,0,0,0.4)";
                ctx.shadowBlur = 12;
                const grad = ctx.createLinearGradient(player.x, player.y, player.x, player.y + player.height);
                grad.addColorStop(0, "#FFEA00");
                grad.addColorStop(1, "#FFC107");
                ctx.fillStyle = grad;
                drawRoundedRect(ctx, player.x, player.y, player.width, player.height, 6);
                ctx.restore();
                ctx.save();
                ctx.font = "20px 'Courier New', monospace";
                ctx.fillStyle = "#fff";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 4;
                ctx.fillText("Height: " + Math.floor(maxY), 12, 30);
                ctx.restore();
                if (gameOver) {
                    ctx.save();
                    ctx.font = "40px sans-serif";
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.shadowColor = "black";
                    ctx.shadowBlur = 6;
                    ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
                    ctx.font = "20px sans-serif";
                    ctx.fillText("Press R to Restart", canvas.width / 2, canvas.height / 2 + 40);
                    ctx.restore();
                }
            }
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }
    </script>
</body>
</html>
